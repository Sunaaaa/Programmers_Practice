# 정렬

- sort ()
- sorted()



<br>

## K번째 수 

- 정렬을 이용해 풀이

- 

## 가장 큰 수

- 정렬을 이용해 풀이 

- 가장 큰 수를 만드는 것을 우선으로 정렬한다.

  - 대소 관계 기준
    - [6,10,2]로 주어진 경우
      - [6,2,10]으로 정렬
    - [3,30,34,5,9]로 주어진 경우, 3,30,34에 대한 정렬 기준을 마련해야 한다.
      - 3 VS 33
        - 어떤것이 앞에 나와도 상관없다.
      - 3 VS 30
        - 3이 앞인 경우, 330 => 큰 수
        - 30이 앞인 경우, 303
        - 3이 앞에 나오는 것이 큰 수를 만들 수 있다.
      - 3 VS 34
        - 3이 앞인 경우, 334
        - 34가 앞인 경우, 343 => 큰 수
    - [34,342,343,344]
      - 34 VS 342
        - 34가 앞인 경우, 34342 => 큰 수
        - 342가 앞인 경우, 34234
      - 34 VS 343
        - 34가 앞인 경우, 34343 => 큰 수
        - 343가 앞인 경우, 34334
      - 34 VS 344
        - 34가 앞인 경우, 34344
        - 344가 앞인 경우, 34434 => 큰 수
      - 주어진  numbers의 원소에 대한 조건이 0이상 1,000 로 제한이 되어있다. 
        - 숫자의 4번 인덱스까지만 비교하면 된다. 
          - 34가 앞인 경우, 3434334343...
          - 343가 앞인 경우, 3433434334...
          - 반드시 최소 4번째에서는 대소관계를 알 수 있게 된다.
  - 람다식을 이용해 정렬 키(기준)을 설정한다.

  <br>



### #sol1

```python
def solution(numbers):

    # O(n)
    numbers = [str(x) for x in numbers]

    # O(nlogn)
    numbers.sort(key=lambda x: (x*4)[:4], reverse = True)

    if numbers[0] == '0':
        answer = '0'
    else :
        # O(n)
        answer = ''.join(numbers)

    return answer
 

print(solution([6,10,2]))
print(solution([3,32,33,34]))

# 6210
# 3433332
```

<br>

##### 시간 복잡도 :  O(nlogn)

<br>

## H-Index

- 정렬을 이용해 풀이