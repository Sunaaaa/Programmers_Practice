# 동적 계획법 (Dynamic Programming)

> 주어진 최적화 문제를 재귀적인 방식으로 보다 작은 부분 문제로 나눠 부분 문제를 풀어낸다. 이 해를 조합하여 전체 문제의 해답에 이르는 방식이다. 
>
> 알고리즘의 진행에 따라, **탐색해야 할 범위를 동적으로 결정**함으로써 탐색 범위를 한정할 수 있다. 
>
> 문제의 성질에 따라 동적 계획법으로 풀어냄으로써, 탐색해야 하는 범위를 효과적으로 줄일 수 있다. 



## 예

### 피보나치 수열

- 직전 두항의 합이 다음 항이 되는 수열

<br>

**피보나치 수열을 재귀함수로 구현한다면???**

`f(4) = f(3) + f(2)`

`f(4) = f(2) + f(1) + f(1) + f(0)`

`f(4) = f(1) + f(0) + f(1) + f(1) + f(0)`

- 같은 인자로 재귀함수를 여러번 호출한다는 단점이 있다. 
  - 복잡도 : 지수함수 형태



<br>

**피보나치 수열을 동적 계획법으로 구현한다면???**

`f(0) = 0, f(1) = 1`

`f(2) = f(1) + f(0) = 1`

`f(3) = f(2) + f(1) = 2`

`f(4) = f(3) + f(2) = 3`

- 부분 문제의 답을 먼저 구하고, 이를 이용해 더 큰 문제를 풀어감으로써 전체 문제의 답에 이른다. 
  - 복잡도 : 선형함수 형태
    - 주어진 수에 비례함



<br>

<br>

### Knapsack Problem

> 15kg 의 베낭에 무게와 가치가 각각 다른 물건들이 있다. 가장 높은 값을 가지도록 물건들을 골라 베낭에 담는다. 

<찾아보자





## [문제] N으로 표현

> 숫자 N과 number가 주어질 때, N과 사칙연산만 사용해서 표현할 수 있는 방법 중 N 사용횟수의 최솟값을 return 한다.
>
> - N은 1이상 9이하
> - number는 1이상 32,000 이하
> - 수식에는 괄호와 사칙연산만 가능하며, 나누기 연산에서 나머지는 무시
> - 최솟값이 8보다 크면 -1을 return



 